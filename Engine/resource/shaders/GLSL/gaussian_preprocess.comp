#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "gaussian_common.h"

layout(push_constant) uniform constants {
    uint64_t geomAddress;
    uint64_t bufferAddress;
    uvec2 resolution;
    uint numGaussians;
} PushConstants;

layout(binding = 0, set = 0) uniform CameraUniforms {
    mat4 view;
    mat4 viewInverse;
    mat4 projection;
    mat4 projectionInverse;
    mat4 viewProjection;
    vec2 focal;
    vec2 tanFOV;
    vec3 position;
} camera;

layout(buffer_reference, scalar) buffer Geometry { Gaussian data[]; };
layout(buffer_reference, scalar) buffer ProcessedGeometry { ProcessedGaussian data[]; };
layout(buffer_reference, scalar) buffer KeyList { uint id[]; };

layout (local_size_x = BLOCK_SIZE, local_size_y = 1, local_size_z = 1) in;

mat3 ComputeCovariance3D(vec3 scale, vec4 rotation);
vec3 ComputeCovariance2D(vec3 pos, mat3 cov3D, mat4 view_mat, vec2 focal, vec2 tan_fov);
vec3 ConvertSphericalHarmonicsToRGB(vec3 pos, vec3 cam_pos, float[SPHERICAL_HARMONICS_MAX_COEF] sh);
Rect2D ScreenSpaceRectFromRadius(vec2 pos, float radius, vec2 resolution);

void main() {
    const uint idx = gl_GlobalInvocationID.x;

    // Quit if current thread is not needed. 
    if (idx >= PushConstants.numGaussians) return;

    // Fetch Gaussian from global memory.
    Geometry geom = Geometry(PushConstants.geomAddress);
    Gaussian gaussian = geom.data[idx];

    // TODO - frustrum culling

    // Transform position by camera's projection.
    vec3 pos = gaussian.position;
    vec4 pos_hom = camera.projection * camera.view * vec4(pos, 1.0);
    float pos_w = 1.0 / pos_hom.w; // TODO - check if necessary to add offset.
    vec3 pos_proj = vec3(pos_hom.x * pos_w, pos_hom.y * pos_w, pos_hom.z * pos_w);

    // Compute 3D covariance matrix.
    mat3 cov3D = ComputeCovariance3D(gaussian.scale, gaussian.rotation);

    // Compute 2D screen-space covariance matrix.
    vec3 cov = ComputeCovariance2D(gaussian.position, cov3D, camera.view, camera.focal, camera.tanFOV);
    // Invert covariance matrix (EWA algorithm). Quit if determinant is zero.
    float det = (cov.x * cov.z - cov.y * cov.y); // TODO - explain!
    if(det == 0.0) return;
    float det_inv = 1.0 / det;
    vec3 conic = vec3(cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv); // TODO - explain!

    // Compute screen-space extent.
    float mid = 0.5 * (cov.x + cov.z); // TODO - explain!
    float lambda1 = mid + sqrt(max(0.1, mid * mid - det)); // First eigenvalue of 2D covariance matrix.
    float lambda2 = mid - sqrt(max(0.1, mid * mid - det)); // Second eigenvalue of 2D covariance matrix.
    float extent_radius = ceil(3.0 * sqrt(max(lambda1, lambda2)));
    // Obtain screen-space position.
    vec2 pos_ss = ((pos_proj.xy + 1.0) * PushConstants.resolution.xy - 1.0) * 0.5;
    // Compute bounding rectangle of screen-space tile. Quit if rectangle covers 0 tiles.
    Rect2D rect = ScreenSpaceRectFromRadius(pos_ss, extent_radius, PushConstants.resolution);
    if((rect.right - rect.left) * (rect.top - rect.bottom) == 0) return;

    // Obtain color by converting spherical harmonics coefficients to RGB.
    vec3 color = ConvertSphericalHarmonicsToRGB(pos, camera.position, gaussian.sh);

    // Store processed Gaussian data.
    ProcessedGeometry processed_geom = ProcessedGeometry(PushConstants.bufferAddress);
    processed_geom.data[idx] = ProcessedGaussian(pos_ss, conic, color, gaussian.opacity);
    // TODO - save depth.
    // TODO - save radii.
    // TODO - save tiles touched.
}

Rect2D ScreenSpaceRectFromRadius(vec2 pos, float radius, vec2 resolution) {
    uint left   = clamp(uint(pos.x - radius) / BLOCK_X, 0, uint(resolution.x));
    uint bottom = clamp(uint(pos.y - radius) / BLOCK_Y, 0, uint(resolution.y));
    uint right  = clamp(uint(pos.x + radius + BLOCK_Y - 1) / BLOCK_X, 0, uint(resolution.x));
    uint top    = clamp(uint(pos.y + radius + BLOCK_Y - 1) / BLOCK_Y, 0, uint(resolution.y));
    return Rect2D(left, bottom, right, top);
}

mat3 ComputeCovariance3D(vec3 scale, vec4 rotation) {
    // Create scale matrix.
    mat3 scale_mat = mat3(1.0); // Identity matrix.
    scale_mat[0][0] = scale.x;
    scale_mat[1][1] = scale.y;
    scale_mat[2][2] = scale.z;

    // Create rotation matrix.
    float r = rotation.x;
	float x = rotation.y;
	float y = rotation.z;
	float z = rotation.w;
    vec3 c1 = vec3(1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y - r * z), 2.0 * (x * z + r * y));
    vec3 c2 = vec3(2.0 * (x * y + r * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z - r * x));
    vec3 c3 = vec3(2.0 * (x * z - r * y), 2.0 * (y * z + r * x), 1.0 - 2.0 * (x * x + y * y));
    mat3 rotation_mat = mat3(c1, c2, c3);

    // Multiply scale and rotation matrices.
    mat3 mat = scale_mat * rotation_mat;
    // Compute 3D world covariance matrix sigma.
    return transpose(mat) * mat;
}

vec3 ComputeCovariance2D(vec3 pos, mat3 cov3D, mat4 view_mat, vec2 focal, vec2 tan_fov) {
    vec3 t = vec3(view_mat * vec4(pos, 1.0));

    vec2 lim = 1.3 * tan_fov;
    t.xy = min(lim, max(-lim, t.xy / t.z)) * t.z;
    
    mat3 J = mat3(
        focal.x / t.z, 0.0, -(focal.x * t.x) / (t.z * t.z),
        0.0, focal.y / t.z, -(focal.y * t.y) / (t.z * t.z),
        0,0,0);

    mat3 W = transpose(mat3(view_mat));
    mat3 T = W * J;

    mat3 Vrk = mat3(
        cov3D[0][0], cov3D[0][1], cov3D[0][2],
        cov3D[0][1], cov3D[1][1], cov3D[1][2],
        cov3D[0][2], cov3D[1][2], cov3D[2][2]);

    mat3 cov = transpose(T) * transpose(Vrk) * T;

    cov[0][0] += 0.3;
    cov[1][1] += 0.3;
    return vec3(cov[0][0], cov[0][1], cov[1][1]);
}

vec3 ConvertSphericalHarmonicsToRGB(vec3 pos, vec3 cam_pos, float[SPHERICAL_HARMONICS_MAX_COEF] sh) {
    vec3 dir = normalize(pos - cam_pos);

    // Set result for degree 0.
    vec3 result = SH_C0 * vec3(sh[0], sh[1], sh[2]);
    if(SPHERICAL_HARMONICS_DEGREE > 0) {
        float x = dir.x, y = dir.y, z = dir.z;
        // Set result for degree 1.
        result = result - 
            SH_C1 * y * vec3(sh[3],  sh[4],  sh[5]) + 
            SH_C1 * z * vec3(sh[6],  sh[7],  sh[8]) - 
            SH_C1 * x * vec3(sh[9], sh[10], sh[11]);
        
        if(SPHERICAL_HARMONICS_DEGREE > 1) {
            float xx = x * x, yy = y * y, zz = z * z;
            float xy = x * y, yz = y * z, xz = x * z;
            // Set result for degree 2.
            result = result + 
                SH_C2[0] * vec3(sh[12], sh[13], sh[14]) * xy + 
                SH_C2[1] * vec3(sh[15], sh[16], sh[17]) * yz + 
                SH_C2[2] * vec3(sh[18], sh[19], sh[20]) * (2.0 * zz - xx - yy) + 
                SH_C2[3] * vec3(sh[21], sh[22], sh[23]) * xz + 
                SH_C2[4] * vec3(sh[24], sh[25], sh[26]) * (xx - yy);
            
            if(SPHERICAL_HARMONICS_DEGREE > 2) {
                // Set result for degree 3.
                result = result + 
                    SH_C3[0] * vec3(sh[27], sh[28], sh[29]) * y * (3.0 * xx - yy) + 
                    SH_C3[1] * vec3(sh[30], sh[31], sh[32]) * xy * z + 
                    SH_C3[2] * vec3(sh[33], sh[34], sh[35]) * y * (4.0 * zz - xx - yy) + 
                    SH_C3[3] * vec3(sh[36], sh[37], sh[38]) * z * (2.0 * zz - 3.0 * xx - 3.0 * yy) + 
                    SH_C3[4] * vec3(sh[39], sh[40], sh[41]) * x * (4.0 * zz - xx - yy) + 
                    SH_C3[5] * vec3(sh[42], sh[43], sh[44]) * z * (xx - yy) + 
                    SH_C3[6] * vec3(sh[45], sh[46], sh[47]) * x * (xx - 3.0 * yy);
            }
        }
    }
    result += 0.5;
    return max(result, 0);
}