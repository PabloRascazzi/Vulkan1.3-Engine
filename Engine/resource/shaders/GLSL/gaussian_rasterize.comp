#version 460
#extension GL_KHR_vulkan_glsl : enable

layout(push_constant) uniform constants {
    uvec2 resolution;
} PushConstants;

layout(binding = 0, set = 1, rgba32f) uniform image2D image;
// TODO - layout(binding = 1, set = 1) uniform GeometryBuffer geom;

const int BLOCK_X = 32, BLOCK_Y = 32;
const int BLOCK_SIZE = BLOCK_X * BLOCK_Y;
layout (local_size_x = BLOCK_X, local_size_y = BLOCK_Y, local_size_z = 1) in;

shared int collected_id[BLOCK_SIZE];
shared vec2 collected_xy[BLOCK_SIZE];
shared vec4 collected_conic_opacity[BLOCK_SIZE];
shared uint num_done;

void main() {
    const uvec3 group = gl_WorkGroupID;
    const uvec3 thread = gl_LocalInvocationID;
    const uint rank = gl_LocalInvocationIndex;

    // Get min and max pixel range of current tile.
    const uvec2 pix_min = uvec2(group.x * BLOCK_X, group.y * BLOCK_Y);
    const uvec2 pix_max = uvec2(min(pix_min.x + BLOCK_X, PushConstants.resolution.x), min(pix_min.y + BLOCK_Y, PushConstants.resolution.y));
    // Get current pixel index.
    const uvec2 pix = uvec2(pix_min.x + thread.x, pix_min.y + thread.y);

    // Check if current pixel is inside render surface bounds.
    bool inside = pix.x < PushConstants.resolution.x && pix.y < PushConstants.resolution.y;
    // Done threads can help with fetching, but don't rasterize.
    bool done = !inside;
    if (done) atomicAdd(num_done, 1);

    // TODO
    ivec2 range = ivec2(0,1);
    int rounds = (range.y - range.x + BLOCK_SIZE) / BLOCK_SIZE;
    int todo = range.y - range.x;

    // Initialize aggregating variables.
    float alpha = 1.0;
    vec3 color = vec3(0);

    // Iterate over all Gaussians within range by batches of BLOCK_SIZE.
    for (int i = 0; i < rounds; i++, todo -= BLOCK_SIZE) {
        // Sync shared memory between threads.
        memoryBarrierShared();
        barrier();

        // Check if all threads are done rendering.
        if (num_done == BLOCK_SIZE) break;

        // Collectively fetch Gaussian data from global memory to shared memory.
        int progress = i * BLOCK_SIZE + int(rank);
        if(range.x + progress < range.y) {
            // TODO
        }

        // Sync shared memory between threads.
        memoryBarrierShared();
        barrier();

        // Iterate over current batch of collected Gaussians.
        for (int j = 0; !done && j < min(BLOCK_SIZE, todo); j++) {
            // Initialize helper variable for current Gaussian.
            vec2 xy = collected_xy[j];
            vec2 delta_xy = xy - vec2(pix.xy);
            vec3 conic = collected_conic_opacity[j].xyz;
            float opacity = collected_conic_opacity[j].w;

            // Resample using conic matrix (cf. "Surface Splatting" by Zwicker et al., 2001)
            // Obtain the exponential falloff from mean.
            float power = -0.5 * (conic.x * delta_xy.x * delta_xy.x + conic.z * delta_xy.y * delta_xy.y) - conic.y * delta_xy.x * delta_xy.y;
            if (power > 0.0) continue;

            // Eq. (2) from 3D Gaussian splatting paper.
            // Obtain aplha by multiplying Gaussian opacity with exponential falloff from mean.
            // Skip Gaussian if opacity is smaller than color range.
            float a = opacity * exp(power);
            if(a < 1.0 / 255.0) continue;
            
            // Obtain color from geometry list using id.
            // TODO - fetch color from geometry buffer.
            color += vec3(0,0,1);
            alpha += a;

            // Set thread to done when alpha reaches its max value.
            done = alpha > 1.0;
            if (done) atomicAdd(num_done, 1);
        }           
    }

    // All valid pixel threads write resulting color to image buffer.
    if(inside) {
        imageStore(image, ivec2(pix), vec4(color, alpha));
    }
}