#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "gaussian_common.h"

layout(push_constant) uniform constants {
    uint64_t geomAddress;
    // TODO - uint64_t keysAddress;
    uvec2 resolution;
    uint numGaussians;
} PushConstants;

layout(binding = 0, set = 0, rgba32f) uniform image2D image;
layout(buffer_reference, scalar) readonly buffer ProcessedGeometry { ProcessedGaussian data[]; };
layout(buffer_reference, scalar) readonly buffer KeyList { uint id[]; };

layout (local_size_x = BLOCK_X, local_size_y = BLOCK_Y, local_size_z = 1) in;

shared uint num_done;
shared ProcessedGaussian collected_geom[BLOCK_SIZE];

void main() {
    const uvec3 group = gl_WorkGroupID;
    const uvec3 thread = gl_LocalInvocationID;
    const uint rank = gl_LocalInvocationIndex;
    ProcessedGeometry geom = ProcessedGeometry(PushConstants.geomAddress);
    // TODO - KeyList key_list = KeyList(PushConstants.keysAddress);

    // Get min and max pixel range of current tile.
    const uvec2 pix_min = uvec2(group.x * BLOCK_X, group.y * BLOCK_Y);
    const uvec2 pix_max = uvec2(min(pix_min.x + BLOCK_X, PushConstants.resolution.x), min(pix_min.y + BLOCK_Y, PushConstants.resolution.y));
    // Get current pixel index.
    const uvec2 pix = uvec2(pix_min.x + thread.x, pix_min.y + thread.y);

    // Check if current pixel is inside render surface bounds.
    bool inside = pix.x < PushConstants.resolution.x && pix.y < PushConstants.resolution.y;
    // Done threads can help with fetching, but don't rasterize.
    bool done = !inside;
    if (done) atomicAdd(num_done, 1);

    // Fetch range of sorted Gaussian IDs to process.
    ivec2 range = ivec2(0, PushConstants.numGaussians); // TODO
    int batches = (range.y - range.x + BLOCK_SIZE) / BLOCK_SIZE;
    int todo = range.y - range.x;

    // Initialize aggregating variables.
    float alpha_inv = 1.0;
    float alpha = 0.0;
    vec3 color = vec3(0);

    // Iterate over all Gaussians within range by batches of BLOCK_SIZE.
    for (int i = 0; i < batches; i++, todo -= BLOCK_SIZE) {
        // Sync shared memory between threads.
        memoryBarrierShared();
        barrier();

        // Check if all threads are done rendering.
        if (num_done == BLOCK_SIZE) break;

        // Collectively fetch Gaussian data from global memory to shared memory.
        int progress = i * BLOCK_SIZE + int(rank);
        if(range.x + progress < range.y) {
            // TODO - uint coll_id = key_list.id[range.x + progress];
            uint coll_id = range.x + progress;
            collected_geom[rank] = geom.data[coll_id];
        }

        // Sync shared memory between threads.
        memoryBarrierShared();
        barrier();

        // Iterate over current batch of collected Gaussians.
        for (int j = 0; !done && j < min(BLOCK_SIZE, todo); j++) {
            // Initialize helper variable for current Gaussian.
            vec2 xy = collected_geom[j].mean2D;
            vec2 delta_xy = xy - vec2(pix.xy);
            vec3 conic = collected_geom[j].conic;
            float opacity = collected_geom[j].opacity;

            // Resample using conic matrix (cf. "Surface Splatting" by Zwicker et al., 2001)
            // Obtain the exponential falloff from mean.
            float power = -0.5 * (conic.x * delta_xy.x * delta_xy.x + conic.z * delta_xy.y * delta_xy.y) - conic.y * delta_xy.x * delta_xy.y;
            if (power > 0.0) continue;

            // Eq. (2) from 3D Gaussian splatting paper.
            // Obtain aplha by multiplying Gaussian opacity with exponential falloff from mean.
            // Skip Gaussian if opacity is smaller than color range.
            float a = opacity * exp(power);
            if(a < 1.0 / 255.0) continue;
            
            // Check if the inverse alpha value is near 0.
            // If so, pixel is done accumulating color.
            float test = alpha_inv * (1 - a);
			if (test < 0.00001) {
				done = true;
                if (done) atomicAdd(num_done, 1);
				continue;
			}

            // Obtain color from geometry list using id.
            // Increment color and alpha, and set inverse alpha.
            color += collected_geom[j].color * a;
            alpha += a;
            alpha_inv = test; 
        }           
    }

    // All valid pixel threads write resulting color to image buffer.
    if(inside) {
        imageStore(image, ivec2(pix), vec4(color, alpha));
    }
}